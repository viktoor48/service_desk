import { ref as C, computed as g, watch as I, nextTick as z, onBeforeUnmount as he, reactive as pe, onMounted as Ae, getCurrentInstance as Ie, inject as Je, shallowReactive as _, markRaw as te, defineComponent as me, useAttrs as Re, toRef as ae, openBlock as B, createBlock as U, Teleport as Qe, unref as v, withDirectives as ue, createElementBlock as N, mergeProps as x, withKeys as _e, withModifiers as ke, Transition as Ve, toHandlers as Ee, withCtx as ye, normalizeClass as eo, normalizeStyle as oo, vShow as ce, createCommentVNode as Y, createVNode as to, renderSlot as Be, normalizeProps as Fe, guardReactiveProps as no, createElementVNode as ee, Fragment as lo, renderList as Oe, resolveDynamicComponent as de, createSlots as so } from "vue";
import { useEventListener as F, tryOnUnmounted as ro } from "@vueuse/core";
import { useFocusTrap as io } from "@vueuse/integrations/useFocusTrap";
const ao = (e) => (...o) => {
  e && (e == null || e(...o), e = null);
}, q = () => {
};
function oe(e, o, l) {
  return e > l ? l : e < o ? o : e;
}
const we = (e) => typeof e == "string";
function fe(e, o) {
  var s;
  const l = ((s = $(e, o)) == null ? void 0 : s[0]) || o;
  e.push(l);
}
function $(e, o) {
  const l = e.indexOf(o);
  if (l !== -1)
    return e.splice(l, 1);
}
function He(e) {
  return Object.entries(e);
}
const uo = {
  /**
   * @description Set `null | false` to disable teleport.
   * @default `'body'`
   * @example
   * ```js
   * teleportTo: '#modals'
   * ```
   */
  teleportTo: {
    type: [String, null, Boolean, Object],
    default: "body"
  },
  /**
   * @description An uniq name for the open/close a modal via vfm.open/vfm.close APIs.
   * @default `undefined`
   * @example Symbol: `Symbol('MyModal')`
   * @example String: `'AUniqString'`
   * @example Number: `300`
   */
  modalId: {
    type: [String, Number, Symbol],
    default: void 0
  },
  /**
   * @description Display the modal or not.
   * @default `undefined`
   * @example
   * ```js
   * const showModal = ref(false)
   * v-model="showModal"
   * ```
   */
  modelValue: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Render the modal via `if` or `show`.
   * @default `'if'`
   * @example
   * ```js
   * displayDirective: 'if'
   * ```
   * @example
   * ```js
   * displayDirective: 'show'
   * ```
   */
  displayDirective: {
    type: String,
    default: "if",
    validator: (e) => ["if", "show", "visible"].includes(e)
  },
  /**
   * @description Hide the overlay or not.
   * @default `undefined`
   * @example
   * ```js
   * hideOverlay="true"
   * ```
   */
  hideOverlay: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Customize the overlay behavior.
   */
  overlayBehavior: {
    type: String,
    default: "auto",
    validator: (e) => ["auto", "persist"].includes(e)
  },
  /**
   * @description Customize the overlay transition.
   * @default `undefined`
   */
  overlayTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Customize the content transition.
   * @default `undefined`
   */
  contentTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Bind class to vfm__overlay.
   * @default `undefined`
   */
  overlayClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind class to vfm__content.
   * @default `undefined`
   */
  contentClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind style to vfm__overlay.
   * @default `undefined`
   */
  overlayStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Bind style to vfm__content.
   * @default `undefined`
   */
  contentStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Is it allow to close the modal by clicking the overlay.
   * @default `true`
   */
  clickToClose: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Is it allow to close the modal by keypress `esc`.
   * @default `true`
   */
  escToClose: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Is it allow to click outside of the vfm__content when the modal is opened
   * @default `'non-interactive'`
   */
  background: {
    type: String,
    default: "non-interactive",
    validator: (e) => ["interactive", "non-interactive"].includes(e)
  },
  /**
   * @description
   * * Use `{ disabled: true }` to disable the focusTrap.
   * * Checkout the createOptions type here https://github.com/focus-trap/focus-trap for more.
   * @default `{ allowOutsideClick: true }`
   */
  focusTrap: {
    type: [Boolean, Object],
    default: () => ({
      allowOutsideClick: !0
    })
  },
  /**
   * @description Lock body scroll or not when the modal is opened.
   * @default `true`
   */
  lockScroll: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Creates a padding-right when scroll is locked to prevent the page from jumping
   * @default `true`
   */
  reserveScrollBarGap: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Define how to increase the zIndex when there are nested modals
   * @default `({ index }) => 1000 + 2 * index`
   */
  zIndexFn: {
    type: Function,
    default: ({ index: e }) => 1e3 + 2 * e
  },
  /**
   * @description The direction of swiping to close the modal
   * @default `none`
   * @example
   * Set swipeToClose="none" to disable swiping to close
   * ```js
   * swipeToClose="none"
   * ```
   */
  swipeToClose: {
    type: String,
    default: "none",
    validator: (e) => ["none", "up", "right", "down", "left"].includes(e)
  },
  /**
   * @description Threshold for swipe to close
   * @default `0`
   */
  threshold: {
    type: Number,
    default: 0
  },
  /**
   * @description If set `:showSwipeBanner="true"`, only allow clicking `swipe-banner` slot to swipe to close
   * @default `undefined`
   * @example
   * ```js
   * swipeToClose="right"
   * :showSwipeBanner="true"
   * ```
   * ```html
   * <VueFinalModal
   *   ...
   *   swipeToClose="right"
   *   :showSwipeBanner="true"
   * >
   *   <template #swipe-banner>
   *     <div style="position: absolute; height: 100%; top: 0; left: 0; width: 10px;" />
   *   </template>
   *   ...modal content
   * </VueFinalModal>
   * ```
   */
  showSwipeBanner: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description When set `:preventNavigationGestures="true"`, there will be two invisible bars for prevent navigation gestures including swiping back/forward on mobile webkit. For example: Safari mobile.
   * @default `undefined`
   * @example
   * Set preventNavigationGestures="true" to prevent Safari navigation gestures including swiping back/forward.
   * ```js
   * :preventNavigationGestures="true"
   * ```
   */
  preventNavigationGestures: {
    type: Boolean,
    default: void 0
  }
};
function De(e = !1) {
  const o = C(e), l = C(o.value ? 0 : void 0);
  return [o, l, {
    beforeEnter() {
      l.value = 1;
    },
    afterEnter() {
      l.value = 0;
    },
    beforeLeave() {
      l.value = 3;
    },
    afterLeave() {
      l.value = 2;
    }
  }];
}
function co(e, o) {
  const { modelValueLocal: l, onEntering: s, onEnter: u, onLeaving: c, onLeave: a } = o, n = C(l.value), [t, r, m] = De(n.value), [f, M, S] = De(n.value), V = g(() => typeof e.contentTransition == "string" ? { name: e.contentTransition, appear: !0 } : { appear: !0, ...e.contentTransition }), O = g(() => typeof e.overlayTransition == "string" ? { name: e.overlayTransition, appear: !0 } : { appear: !0, ...e.overlayTransition }), E = g(
    () => (e.hideOverlay || M.value === 2) && r.value === 2
    /* Leave */
  );
  I(
    E,
    (k) => {
      k && (n.value = !1);
    }
  ), I(r, (k) => {
    if (k === 1) {
      if (!n.value)
        return;
      s == null || s();
    } else if (k === 0) {
      if (!n.value)
        return;
      u == null || u();
    } else
      k === 3 ? c == null || c() : k === 2 && (a == null || a());
  });
  async function T() {
    n.value = !0, await z(), t.value = !0, f.value = !0;
  }
  function D() {
    t.value = !1, f.value = !1;
  }
  return {
    visible: n,
    contentVisible: t,
    contentListeners: m,
    contentTransition: V,
    overlayVisible: f,
    overlayListeners: S,
    overlayTransition: O,
    enterTransition: T,
    leaveTransition: D
  };
}
function fo(e, o, l) {
  const { vfmRootEl: s, vfmContentEl: u, visible: c, modelValueLocal: a } = l, n = C();
  function t() {
    c.value && e.escToClose && (a.value = !1);
  }
  function r(f) {
    n.value = f == null ? void 0 : f.target;
  }
  function m() {
    var f;
    n.value === s.value && (e.clickToClose ? a.value = !1 : ((f = u.value) == null || f.focus(), o("clickOutside")));
  }
  return {
    onEsc: t,
    onMouseupRoot: m,
    onMousedown: r
  };
}
function vo(e, o, l) {
  let s = !1;
  const { open: u, close: c } = l, a = C(!1), n = {
    get value() {
      return a.value;
    },
    set value(r) {
      t(r);
    }
  };
  function t(r) {
    (r ? u() : c()) ? (a.value = r, r !== e.modelValue && o("update:modelValue", r)) : (s = !0, o("update:modelValue", !r), z(() => {
      s = !1;
    }));
  }
  return I(() => e.modelValue, (r) => {
    s || (n.value = !!r);
  }), {
    modelValueLocal: n
  };
}
function po(e, o) {
  if (e.focusTrap === !1)
    return {
      focus() {
      },
      blur() {
      }
    };
  const { focusEl: l } = o, { hasFocus: s, activate: u, deactivate: c } = io(l, e.focusTrap);
  function a() {
    requestAnimationFrame(() => {
      u();
    });
  }
  function n() {
    s.value && c();
  }
  return { focus: a, blur: n };
}
let be = !1;
if (typeof window < "u") {
  const e = {
    get passive() {
      be = !0;
    }
  };
  window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
}
const je = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
let j = [], le = !1, ne = 0, Ne = -1, W, X;
const yo = (e) => {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const o = window.getComputedStyle(e);
  return ["auto", "scroll"].includes(o.overflowY) && e.scrollHeight > e.clientHeight;
}, ho = (e, o) => !(e.scrollTop === 0 && o < 0 || e.scrollTop + e.clientHeight + o >= e.scrollHeight && o > 0), mo = (e) => {
  const o = [];
  for (; e; ) {
    if (o.push(e), e.classList.contains("vfm"))
      return o;
    e = e.parentElement;
  }
  return o;
}, wo = (e, o) => {
  let l = !1;
  return mo(e).forEach((u) => {
    yo(u) && ho(u, o) && (l = !0);
  }), l;
}, Ye = (e) => j.some(() => wo(e, -ne)), se = (e) => {
  const o = e || window.event;
  return Ye(o.target) || o.touches.length > 1 ? !0 : (o.preventDefault && o.preventDefault(), !1);
}, bo = (e) => {
  if (X === void 0) {
    const o = !!e && e.reserveScrollBarGap === !0, l = window.innerWidth - document.documentElement.clientWidth;
    if (o && l > 0) {
      const s = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
      X = document.body.style.paddingRight, document.body.style.paddingRight = `${s + l}px`;
    }
  }
  W === void 0 && (W = document.body.style.overflow, document.body.style.overflow = "hidden");
}, To = () => {
  X !== void 0 && (document.body.style.paddingRight = X, X = void 0), W !== void 0 && (document.body.style.overflow = W, W = void 0);
}, So = (e) => e ? e.scrollHeight - e.scrollTop <= e.clientHeight : !1, Mo = (e, o) => (ne = e.targetTouches[0].clientY - Ne, Ye(e.target) ? !1 : o && o.scrollTop === 0 && ne > 0 || So(o) && ne < 0 ? se(e) : (e.stopPropagation(), !0)), go = (e, o) => {
  if (!e) {
    console.error(
      "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
    );
    return;
  }
  if (j.some((s) => s.targetElement === e))
    return;
  const l = {
    targetElement: e,
    options: o || {}
  };
  j = [...j, l], je ? (e.ontouchstart = (s) => {
    s.targetTouches.length === 1 && (Ne = s.targetTouches[0].clientY);
  }, e.ontouchmove = (s) => {
    s.targetTouches.length === 1 && Mo(s, e);
  }, le || (document.addEventListener("touchmove", se, be ? { passive: !1 } : void 0), le = !0)) : bo(o);
}, Co = (e) => {
  if (!e) {
    console.error(
      "enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."
    );
    return;
  }
  j = j.filter((o) => o.targetElement !== e), je ? (e.ontouchstart = null, e.ontouchmove = null, le && j.length === 0 && (document.removeEventListener("touchmove", se, be ? { passive: !1 } : void 0), le = !1)) : j.length || To();
};
function ko(e, o) {
  const { lockScrollEl: l, modelValueLocal: s } = o;
  let u;
  I(l, (n) => {
    n && (u = n);
  }, { immediate: !0 }), I(() => e.lockScroll, (n) => {
    n ? a() : c();
  }), he(() => {
    c();
  });
  function c() {
    u && Co(u);
  }
  function a() {
    s.value && e.lockScroll && u && go(u, {
      reserveScrollBarGap: e.reserveScrollBarGap,
      allowTouchMove: (n) => {
        for (; n && n !== document.body; ) {
          if (n.getAttribute("vfm-scroll-lock-ignore") !== null)
            return !0;
          n = n.parentElement;
        }
        return !1;
      }
    });
  }
  return {
    enableBodyScroll: c,
    disableBodyScroll: a
  };
}
function Vo(e) {
  const o = C();
  function l(u) {
    var c;
    o.value = (c = e.zIndexFn) == null ? void 0 : c.call(e, { index: u <= -1 ? 0 : u });
  }
  function s() {
    o.value = void 0;
  }
  return {
    zIndex: o,
    refreshZIndex: l,
    resetZIndex: s
  };
}
const ve = {
  beforeMount(e, { value: o }, { transition: l }) {
    e._vov = e.style.visibility === "hidden" ? "" : e.style.visibility, l && o ? l.beforeEnter(e) : G(e, o);
  },
  mounted(e, { value: o }, { transition: l }) {
    l && o && l.enter(e);
  },
  updated(e, { value: o, oldValue: l }, { transition: s }) {
    !o != !l && (s ? o ? (s.beforeEnter(e), G(e, !0), s.enter(e)) : s.leave(e, () => {
      G(e, !1);
    }) : G(e, o));
  },
  beforeUnmount(e, { value: o }) {
    G(e, o);
  }
};
function G(e, o) {
  e.style.visibility = o ? e._vov : "hidden";
}
const Le = (e) => {
  if (e instanceof MouseEvent) {
    const { clientX: o, clientY: l } = e;
    return { x: o, y: l };
  } else {
    const { clientX: o, clientY: l } = e.targetTouches[0];
    return { x: o, y: l };
  }
};
function Eo(e) {
  if (!e)
    return !1;
  let o = !1;
  const l = {
    get passive() {
      return o = !0, !1;
    }
  };
  return e.addEventListener("x", q, l), e.removeEventListener("x", q), o;
}
function Bo(e, {
  threshold: o = 0,
  onSwipeStart: l,
  onSwipe: s,
  onSwipeEnd: u,
  passive: c = !0
}) {
  const a = pe({ x: 0, y: 0 }), n = pe({ x: 0, y: 0 }), t = g(() => a.x - n.x), r = g(() => a.y - n.y), { max: m, abs: f } = Math, M = g(
    () => m(f(t.value), f(r.value)) >= o
  ), S = C(!1), V = g(() => M.value ? f(t.value) > f(r.value) ? t.value > 0 ? "left" : "right" : r.value > 0 ? "up" : "down" : "none"), O = (p, h) => {
    a.x = p, a.y = h;
  }, E = (p, h) => {
    n.x = p, n.y = h;
  };
  let T, D;
  function k(p) {
    T.capture && !T.passive && p.preventDefault();
    const { x: h, y: R } = Le(p);
    O(h, R), E(h, R), l == null || l(p), D = [
      F(e, "mousemove", P, T),
      F(e, "touchmove", P, T),
      F(e, "mouseup", i, T),
      F(e, "touchend", i, T),
      F(e, "touchcancel", i, T)
    ];
  }
  function P(p) {
    const { x: h, y: R } = Le(p);
    E(h, R), !S.value && M.value && (S.value = !0), S.value && (s == null || s(p));
  }
  function i(p) {
    S.value && (u == null || u(p, V.value)), S.value = !1, D.forEach((h) => h());
  }
  let w = [];
  return Ae(() => {
    const p = Eo(window == null ? void 0 : window.document);
    c ? T = p ? { passive: !0 } : { capture: !1 } : T = p ? { passive: !1, capture: !0 } : { capture: !0 }, w = [
      F(e, "mousedown", k, T),
      F(e, "touchstart", k, T)
    ];
  }), {
    isSwiping: S,
    direction: V,
    coordsStart: a,
    coordsEnd: n,
    lengthX: t,
    lengthY: r,
    stop: () => {
      w.forEach((p) => p()), D.forEach((p) => p());
    }
  };
}
function Oo(e, o) {
  const { vfmContentEl: l, modelValueLocal: s } = o, u = 0.1, c = 300, a = C(), n = g(() => {
    if (!(e.swipeToClose === void 0 || e.swipeToClose === "none"))
      return e.showSwipeBanner ? a.value : l.value;
  }), t = C(0), r = C(!0);
  let m = q, f = !0, M, S = !1;
  const { lengthX: V, lengthY: O, direction: E, isSwiping: T } = Bo(n, {
    threshold: e.threshold,
    onSwipeStart(i) {
      m = F(document, "selectionchange", () => {
        var w;
        r.value = (w = window.getSelection()) == null ? void 0 : w.isCollapsed;
      }), M = (/* @__PURE__ */ new Date()).getTime(), S = P(i == null ? void 0 : i.target);
    },
    onSwipe() {
      var i, w, L, p;
      if (S && r.value && E.value === e.swipeToClose) {
        if (E.value === "up") {
          const h = oe(Math.abs(O.value || 0), 0, ((i = n.value) == null ? void 0 : i.offsetHeight) || 0) - (e.threshold || 0);
          t.value = h;
        } else if (E.value === "down") {
          const h = oe(Math.abs(O.value || 0), 0, ((w = n.value) == null ? void 0 : w.offsetHeight) || 0) - (e.threshold || 0);
          t.value = -h;
        } else if (E.value === "right") {
          const h = oe(Math.abs(V.value || 0), 0, ((L = n.value) == null ? void 0 : L.offsetWidth) || 0) - (e.threshold || 0);
          t.value = -h;
        } else if (E.value === "left") {
          const h = oe(Math.abs(V.value || 0), 0, ((p = n.value) == null ? void 0 : p.offsetWidth) || 0) - (e.threshold || 0);
          t.value = h;
        }
      }
    },
    onSwipeEnd(i, w) {
      if (m(), !r.value) {
        r.value = !0;
        return;
      }
      const L = (/* @__PURE__ */ new Date()).getTime(), p = w === e.swipeToClose, h = (() => {
        var J, Q;
        if (w === "up" || w === "down")
          return Math.abs((O == null ? void 0 : O.value) || 0) > u * (((J = n.value) == null ? void 0 : J.offsetHeight) || 0);
        if (w === "left" || w === "right")
          return Math.abs((V == null ? void 0 : V.value) || 0) > u * (((Q = n.value) == null ? void 0 : Q.offsetWidth) || 0);
      })(), R = L - M <= c;
      if (f && S && p && (h || R)) {
        s.value = !1;
        return;
      }
      t.value = 0;
    }
  }), D = g(() => {
    if (e.swipeToClose === "none")
      return;
    const i = (() => {
      switch (e.swipeToClose) {
        case "up":
        case "down":
          return "translateY";
        case "left":
        case "right":
          return "translateX";
      }
    })();
    return {
      class: { "vfm-bounce-back": !T.value },
      style: { transform: `${i}(${-t.value}px)` }
    };
  });
  I(
    () => r.value,
    (i) => {
      i || (t.value = 0);
    }
  ), I(
    () => s.value,
    (i) => {
      i && (t.value = 0);
    }
  ), I(
    () => t.value,
    (i, w) => {
      switch (e.swipeToClose) {
        case "down":
        case "right":
          f = i < w;
          break;
        case "up":
        case "left":
          f = i > w;
          break;
      }
    }
  );
  function k(i) {
    e.preventNavigationGestures && i.preventDefault();
  }
  function P(i) {
    const w = i == null ? void 0 : i.tagName;
    if (!w || ["INPUT", "TEXTAREA"].includes(w))
      return !1;
    const L = (() => {
      switch (e.swipeToClose) {
        case "up":
          return (i == null ? void 0 : i.scrollTop) + (i == null ? void 0 : i.clientHeight) === (i == null ? void 0 : i.scrollHeight);
        case "left":
          return (i == null ? void 0 : i.scrollLeft) + (i == null ? void 0 : i.clientWidth) === (i == null ? void 0 : i.scrollWidth);
        case "down":
          return (i == null ? void 0 : i.scrollTop) === 0;
        case "right":
          return (i == null ? void 0 : i.scrollLeft) === 0;
        default:
          return !1;
      }
    })();
    return i === n.value ? L : L && P(i == null ? void 0 : i.parentElement);
  }
  return {
    vfmContentEl: l,
    swipeBannerEl: a,
    bindSwipe: D,
    onTouchStartSwipeBanner: k
  };
}
const xe = Symbol("vfm");
let H;
const Do = (e) => H = e, Lo = {
  install: q,
  modals: [],
  openedModals: [],
  openedModalOverlays: [],
  dynamicModals: [],
  modalsContainers: C([]),
  get: () => {
  },
  toggle: () => {
  },
  open: () => {
  },
  close: () => {
  },
  closeAll: () => Promise.allSettled([])
}, Po = () => Ie() && Je(xe, Lo) || H;
function xo() {
  const e = _([]), o = _([]), l = _([]), s = _([]), u = C([]), c = te({
    install(a) {
      a.provide(xe, c), a.config.globalProperties.$vfm = c;
    },
    modals: e,
    openedModals: o,
    openedModalOverlays: l,
    dynamicModals: s,
    modalsContainers: u,
    get(a) {
      return e.find((n) => {
        var t, r;
        return ((r = (t = Z(n)) == null ? void 0 : t.value.modalId) == null ? void 0 : r.value) === a;
      });
    },
    toggle(a, n) {
      var r;
      const t = c.get(a);
      return (r = Z(t)) == null ? void 0 : r.value.toggle(n);
    },
    open(a) {
      return c.toggle(a, !0);
    },
    close(a) {
      return c.toggle(a, !1);
    },
    closeAll() {
      return Promise.allSettled(
        o.reduce((a, n) => {
          const t = Z(n), r = t == null ? void 0 : t.value.toggle(!1);
          return r && a.push(r), a;
        }, [])
      );
    }
  });
  return Do(c), c;
}
function Z(e) {
  var o;
  return (o = e == null ? void 0 : e.exposed) == null ? void 0 : o.modalExposed;
}
const Ao = me({ inheritAttrs: !1 }), Io = /* @__PURE__ */ me({
  ...Ao,
  __name: "VueFinalModal",
  props: uo,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { expose: o, emit: l }) {
    const s = e, u = l, c = Re(), a = Ie(), { modals: n, openedModals: t, openedModalOverlays: r } = K(), m = C(), f = C(), { focus: M, blur: S } = po(s, { focusEl: m }), { zIndex: V, refreshZIndex: O, resetZIndex: E } = Vo(s), { modelValueLocal: T } = vo(s, u, { open: Xe, close: ge }), { enableBodyScroll: D, disableBodyScroll: k } = ko(s, {
      lockScrollEl: m,
      modelValueLocal: T
    });
    let P = q;
    const {
      visible: i,
      contentVisible: w,
      contentListeners: L,
      contentTransition: p,
      overlayVisible: h,
      overlayListeners: R,
      overlayTransition: J,
      enterTransition: Q,
      leaveTransition: ze
    } = co(s, {
      modelValueLocal: T,
      onEntering() {
        z(() => {
          k(), M();
        });
      },
      onEnter() {
        u("opened"), P("opened");
      },
      onLeave() {
        $(t, a), E(), D(), u("closed"), P("closed");
      }
    }), { onEsc: Ge, onMouseupRoot: $e, onMousedown: Te } = fo(s, u, { vfmRootEl: m, vfmContentEl: f, visible: i, modelValueLocal: T }), {
      swipeBannerEl: Ue,
      bindSwipe: We,
      onTouchStartSwipeBanner: Se
    } = Oo(s, { vfmContentEl: f, modelValueLocal: T }), Me = g(() => a ? t.indexOf(a) : -1);
    I([() => s.zIndexFn, Me], () => {
      i.value && O(Me.value);
    }), Ae(() => {
      fe(n, a);
    }), s.modelValue && (T.value = !0);
    function Xe() {
      let d = !1;
      return u("beforeOpen", { stop: () => d = !0 }), d ? !1 : (fe(t, a), fe(r, a), ie(), Q(), !0);
    }
    function ge() {
      let d = !1;
      return u("beforeClose", { stop: () => d = !0 }), d ? !1 : ($(r, a), ie(), S(), ze(), !0);
    }
    he(() => {
      D(), $(n, a), $(t, a), S(), ie();
    });
    async function ie() {
      await z();
      const d = r.filter((y) => {
        var A;
        const b = Z(y);
        return (b == null ? void 0 : b.value.overlayBehavior.value) === "auto" && !((A = b == null ? void 0 : b.value.hideOverlay) != null && A.value);
      });
      d.forEach((y, b) => {
        const A = Z(y);
        A != null && A.value && (A.value.overlayVisible.value = b === d.length - 1);
      });
    }
    const Ze = ae(() => s.modalId), Ce = ae(() => s.hideOverlay), Ke = ae(() => s.overlayBehavior), qe = g(() => ({
      modalId: Ze,
      hideOverlay: Ce,
      overlayBehavior: Ke,
      overlayVisible: h,
      toggle(d) {
        return new Promise((y) => {
          P = ao((A) => y(A));
          const b = typeof d == "boolean" ? d : !T.value;
          T.value = b;
        });
      }
    }));
    return o({
      modalExposed: qe
    }), (d, y) => (B(), U(Qe, {
      to: d.teleportTo ? d.teleportTo : void 0,
      disabled: !d.teleportTo
    }, [
      d.displayDirective !== "if" || v(i) ? ue((B(), N("div", x({ key: 0 }, v(c), {
        ref_key: "vfmRootEl",
        ref: m,
        class: ["vfm vfm--fixed vfm--inset", { "vfm--prevent-none": d.background === "interactive" }],
        style: { zIndex: v(V) },
        role: "dialog",
        "aria-modal": "true",
        onKeydown: y[7] || (y[7] = _e(() => v(Ge)(), ["esc"])),
        onMouseup: y[8] || (y[8] = ke(() => v($e)(), ["self"])),
        onMousedown: y[9] || (y[9] = ke((b) => v(Te)(b), ["self"]))
      }), [
        Ce.value ? Y("", !0) : (B(), U(Ve, x({ key: 0 }, v(J), Ee(v(R))), {
          default: ye(() => [
            d.displayDirective !== "if" || v(h) ? ue((B(), N("div", {
              key: 0,
              class: eo(["vfm__overlay vfm--overlay vfm--absolute vfm--inset vfm--prevent-none", d.overlayClass]),
              style: oo(d.overlayStyle),
              "aria-hidden": "true"
            }, null, 6)), [
              [ce, d.displayDirective !== "show" || v(h)],
              [v(ve), d.displayDirective !== "visible" || v(h)]
            ]) : Y("", !0)
          ]),
          _: 1
        }, 16)),
        to(Ve, x(v(p), Ee(v(L))), {
          default: ye(() => [
            d.displayDirective !== "if" || v(w) ? ue((B(), N("div", x({
              key: 0,
              ref_key: "vfmContentEl",
              ref: f,
              class: ["vfm__content vfm--outline-none", [d.contentClass, { "vfm--prevent-auto": d.background === "interactive" }]],
              style: d.contentStyle,
              tabindex: "0"
            }, v(We), {
              onMousedown: y[6] || (y[6] = () => v(Te)())
            }), [
              Be(d.$slots, "default", Fe(no({ close: ge }))),
              d.showSwipeBanner ? (B(), N("div", {
                key: 0,
                ref_key: "swipeBannerEl",
                ref: Ue,
                class: "vfm-swipe-banner-container",
                onTouchstart: y[2] || (y[2] = (b) => v(Se)(b))
              }, [
                Be(d.$slots, "swipe-banner", {}, () => [
                  ee("div", {
                    class: "vfm-swipe-banner-back",
                    onTouchstart: y[0] || (y[0] = (b) => d.swipeToClose === "left" && b.preventDefault())
                  }, null, 32),
                  ee("div", {
                    class: "vfm-swipe-banner-forward",
                    onTouchstart: y[1] || (y[1] = (b) => d.swipeToClose === "right" && b.preventDefault())
                  }, null, 32)
                ])
              ], 544)) : !d.showSwipeBanner && d.preventNavigationGestures ? (B(), N("div", {
                key: 1,
                class: "vfm-swipe-banner-container",
                onTouchstart: y[5] || (y[5] = (b) => v(Se)(b))
              }, [
                ee("div", {
                  class: "vfm-swipe-banner-back",
                  onTouchstart: y[3] || (y[3] = (b) => d.swipeToClose === "left" && b.preventDefault())
                }, null, 32),
                ee("div", {
                  class: "vfm-swipe-banner-forward",
                  onTouchstart: y[4] || (y[4] = (b) => d.swipeToClose === "right" && b.preventDefault())
                }, null, 32)
              ], 32)) : Y("", !0)
            ], 16)), [
              [ce, d.displayDirective !== "show" || v(w)],
              [v(ve), d.displayDirective !== "visible" || v(w)]
            ]) : Y("", !0)
          ]),
          _: 3
        }, 16)
      ], 16)), [
        [ce, d.displayDirective !== "show" || v(i)],
        [v(ve), d.displayDirective !== "visible" || v(i)]
      ]) : Y("", !0)
    ], 8, ["to", "disabled"]));
  }
});
function K() {
  const e = Po();
  if (!e)
    throw new Error(
      `[Vue Final Modal]: getActiveVfm was called with no active Vfm. Did you forget to install vfm?
	const vfm = createVfm()
	app.use(vfm)
This will fail in production.`
    );
  return e;
}
function Pe(e, o = Io) {
  const { component: l, slots: s, ...u } = e, c = typeof s > "u" ? {} : Object.fromEntries(He(s).map(([a, n]) => we(n) ? [a, n] : re(n) ? [a, {
    ...n,
    component: te(n.component)
  }] : [a, te(n)]));
  return {
    ...u,
    component: te(l || o),
    slots: c
  };
}
function zo(e) {
  const o = pe({
    id: Symbol("useModal"),
    modelValue: !!(e != null && e.defaultModelValue),
    resolveOpened: () => {
    },
    resolveClosed: () => {
    },
    attrs: {},
    ...Pe(e)
  });
  ro(() => {
    o != null && o.keepAlive || n();
  }), o.modelValue === !0 && (H ? H == null || H.dynamicModals.push(o) : z(() => {
    const t = K();
    t == null || t.dynamicModals.push(o);
  }));
  async function l() {
    let t;
    return H ? t = H : (await z(), t = K()), o.modelValue ? Promise.resolve("[Vue Final Modal] modal is already opened.") : (n(), o.modelValue = !0, t.dynamicModals.push(o), new Promise((r) => {
      o.resolveOpened = () => r("opened");
    }));
  }
  function s() {
    return o.modelValue ? (o.modelValue = !1, new Promise((t) => {
      o.resolveClosed = () => t("closed");
    })) : Promise.resolve("[Vue Final Modal] modal is already closed.");
  }
  function u(t) {
    const { slots: r, ...m } = Pe(t, o.component);
    t.defaultModelValue !== void 0 && (o.defaultModelValue = t.defaultModelValue), (t == null ? void 0 : t.keepAlive) !== void 0 && (o.keepAlive = t == null ? void 0 : t.keepAlive), c(o, m), r && He(r).forEach(([f, M]) => {
      const S = o.slots[f];
      we(S) ? o.slots[f] = M : re(S) && re(M) ? c(S, M) : o.slots[f] = M;
    });
  }
  function c(t, r) {
    r.component && (t.component = r.component), r.attrs && a(t.attrs, r.attrs);
  }
  function a(t, r) {
    return Object.entries(r).forEach(([m, f]) => {
      t[m] = f;
    }), t;
  }
  function n() {
    const t = K(), r = t.dynamicModals.indexOf(o);
    r !== -1 && t.dynamicModals.splice(r, 1);
  }
  return {
    options: o,
    open: l,
    close: s,
    patchOptions: u,
    destroy: n
  };
}
function Go(e) {
  return e;
}
function re(e) {
  return typeof e == "object" && e !== null ? "component" in e : !1;
}
function Ro(e, o) {
  return Object.keys(o).reduce((l, s) => (l[s] = e == null ? void 0 : e[s], l), {});
}
function Fo(e) {
  return {
    "onUpdate:modelValue": (o) => e == null ? void 0 : e("update:modelValue", o),
    onBeforeClose: (o) => e == null ? void 0 : e("beforeClose", o),
    onClosed: () => e == null ? void 0 : e("closed"),
    onBeforeOpen: (o) => e == null ? void 0 : e("beforeOpen", o),
    onOpened: () => e == null ? void 0 : e("opened"),
    /** onClickOutside will only be emitted when clickToClose equal to `false` */
    onClickOutside: () => e == null ? void 0 : e("clickOutside")
  };
}
function $o(e) {
  const { props: o, modalProps: l, emit: s } = e, u = g(() => Ro(o, l)), c = Fo(s), a = Re();
  return g(() => ({
    ...u.value,
    ...c,
    ...a
  }));
}
const Ho = ["innerHTML"], Uo = /* @__PURE__ */ me({
  __name: "ModalsContainer",
  setup(e) {
    const { modalsContainers: o, dynamicModals: l } = K(), s = Symbol("ModalsContainer"), u = g(() => {
      var n;
      return s === ((n = o.value) == null ? void 0 : n[0]);
    });
    o.value.push(s), he(() => {
      o.value = o.value.filter((n) => n !== s);
    });
    function c(n) {
      var t, r, m;
      (r = (t = l[n]) == null ? void 0 : t.resolveClosed) == null || r.call(t), (m = l[n]) != null && m.keepAlive || l.splice(n, 1);
    }
    function a(n) {
      var t, r;
      (r = (t = l[n]) == null ? void 0 : t.resolveOpened) == null || r.call(t);
    }
    return (n, t) => u.value ? (B(!0), N(lo, { key: 0 }, Oe(v(l), (r, m) => (B(), U(de(r.component), x({
      key: r.id
    }, {
      displayDirective: r != null && r.keepAlive ? "show" : void 0,
      ...typeof r.attrs == "object" ? r.attrs : {}
    }, {
      modelValue: r.modelValue,
      "onUpdate:modelValue": (f) => r.modelValue = f,
      onClosed: () => c(m),
      onOpened: () => a(m)
    }), so({ _: 2 }, [
      Oe(r.slots, (f, M) => ({
        name: M,
        fn: ye(() => [
          v(we)(f) ? (B(), N("div", {
            key: 0,
            innerHTML: f
          }, null, 8, Ho)) : v(re)(f) ? (B(), U(de(f.component), Fe(x({ key: 1 }, f.attrs)), null, 16)) : (B(), U(de(f), { key: 2 }))
        ])
      }))
    ]), 1040, ["modelValue", "onUpdate:modelValue", "onClosed", "onOpened"]))), 128)) : Y("", !0);
  }
});
export {
  Uo as ModalsContainer,
  Io as VueFinalModal,
  xo as createVfm,
  Z as getModalExposed,
  zo as useModal,
  Go as useModalSlot,
  K as useVfm,
  $o as useVfmAttrs,
  uo as vueFinalModalProps
};
