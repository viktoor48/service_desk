/**
  * vee-validate v4.11.8
  * (c) 2023 Abdelrahman Awad
  * @license MIT
  */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VeeValidateYup = {}));
})(this, (function (exports) { 'use strict';

    const isObject = (obj) => obj !== null && !!obj && typeof obj === 'object' && !Array.isArray(obj);
    function isObjectLike(value) {
        return typeof value === 'object' && value !== null;
    }
    function getTag(value) {
        if (value == null) {
            return value === undefined ? '[object Undefined]' : '[object Null]';
        }
        return Object.prototype.toString.call(value);
    }
    // Reference: https://github.com/lodash/lodash/blob/master/isPlainObject.js
    function isPlainObject(value) {
        if (!isObjectLike(value) || getTag(value) !== '[object Object]') {
            return false;
        }
        if (Object.getPrototypeOf(value) === null) {
            return true;
        }
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    function merge(target, source) {
        Object.keys(source).forEach(key => {
            if (isPlainObject(source[key])) {
                if (!target[key]) {
                    target[key] = {};
                }
                merge(target[key], source[key]);
                return;
            }
            target[key] = source[key];
        });
        return target;
    }

    function toTypedSchema(yupSchema, opts = { abortEarly: false }) {
        const schema = {
            __type: 'VVTypedSchema',
            async parse(values) {
                var _a;
                try {
                    // we spread the options because yup mutates the opts object passed
                    const output = await yupSchema.validate(values, Object.assign({}, opts));
                    return {
                        value: output,
                        errors: [],
                    };
                }
                catch (err) {
                    const error = err;
                    // Yup errors have a name prop one them.
                    // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string
                    if (error.name !== 'ValidationError') {
                        throw err;
                    }
                    if (!((_a = error.inner) === null || _a === void 0 ? void 0 : _a.length) && error.errors.length) {
                        return { errors: [{ path: error.path, errors: error.errors }] };
                    }
                    const errors = error.inner.reduce((acc, curr) => {
                        const path = curr.path || '';
                        if (!acc[path]) {
                            acc[path] = { errors: [], path };
                        }
                        acc[path].errors.push(...curr.errors);
                        return acc;
                    }, {});
                    // list of aggregated errors
                    return { errors: Object.values(errors) };
                }
            },
            cast(values) {
                try {
                    return yupSchema.cast(values);
                }
                catch (_a) {
                    const defaults = yupSchema.getDefault();
                    if (isObject(defaults) && isObject(values)) {
                        return merge(defaults, values);
                    }
                    return values;
                }
            },
        };
        return schema;
    }

    exports.toTypedSchema = toTypedSchema;

}));
